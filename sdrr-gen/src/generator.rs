// src/generator.rs
use crate::config::Config;
use crate::preprocessor::RomImage;
use crate::rom_types::{CsLogic, StmFamily};
use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::PathBuf;

// Generate all output files
pub fn generate_files(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    // Create output directory if it doesn't exist
    if !config.output_dir.exists() {
        fs::create_dir_all(&config.output_dir).with_context(|| {
            format!(
                "Failed to create output directory: {}",
                config.output_dir.display()
            )
        })?;
    }

    // Generate roms.h
    generate_roms_header_file(config, rom_images)?;

    // Generate roms.c
    generate_roms_implementation_file(config, rom_images)?;

    // Generate sdrr_config.h
    generate_sdrr_config_header(config)?;

    // Generate Makefile fragment
    generate_makefile_fragment(config)?;

    Ok(())
}

enum FileType {
    C,
    Makefile,
}

fn create_file(output_dir: &PathBuf, filename: &str, filetype: FileType) -> Result<fs::File> {
    let file_path = output_dir.join(filename);
    let mut file = fs::File::create(&file_path)
        .with_context(|| format!("Failed to create file: {}", file_path.display()))?;

    write_header(filename, &mut file, filetype)?;

    Ok(file)
}

fn write_header(name: &str, file: &mut fs::File, filetype: FileType) -> Result<()> {
    let comment = match filetype {
        FileType::C => "//",
        FileType::Makefile => "#",
    };
    writeln!(file, "{comment} {}", name)?;
    writeln!(file)?;
    writeln!(
        file,
        "{comment} This file was auto-generated by sdrr-gen using the following arguments:"
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment}   {}",
        std::env::args().skip(1).collect::<Vec<_>>().join(" ")
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} Do not edit this file directly - instead rengerate using sdrr-gen."
    )?;
    writeln!(file, "{comment}")?;
    writeln!(
        file,
        "{comment} This is most easily done by modifying the configuration at the beginning"
    )?;
    writeln!(
        file,
        "{comment} of the Makefile in the repostiory root and running `make` from there."
    )?;
    writeln!(file)?;

    Ok(())
}

// Generate roms.h header file
fn generate_roms_header_file(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    const FILENAME: &str = "roms.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_ROMS_H")?;
    writeln!(file, "#define SDRR_ROMS_H")?;
    writeln!(file)?;
    writeln!(file, "#include <stdint.h>")?;
    writeln!(file, "#include \"sdrr_config.h\"")?;
    writeln!(file)?;
    writeln!(file, "// Number of ROM images")?;
    writeln!(file, "#define SDRR_NUM_IMAGES {}", rom_images.len())?;
    writeln!(file)?;

    // Generate individual ROM size defines
    writeln!(
        file,
        "// Individual ROM sizes (generated based on actual ROM types)"
    )?;
    let family = config.stm_variant.family();
    for (i, rom_config) in config.roms.iter().enumerate() {
        let size = match family {
            StmFamily::F1 => rom_config.rom_type.size_bytes(),
            StmFamily::F4 => 16384,
        };
        writeln!(
            file,
            "#define ROM_{}_SIZE {}   // {} type",
            i,
            size,
            rom_config.rom_type.name()
        )?;
    }
    writeln!(file)?;

    // ROM type enumeration
    writeln!(file, "// ROM type enumeration")?;
    writeln!(file, "typedef enum {{")?;
    writeln!(file, "    ROM_TYPE_2316,")?;
    writeln!(file, "    ROM_TYPE_2332,")?;
    writeln!(file, "    ROM_TYPE_2364")?;
    writeln!(file, "}} sdrr_rom_type_t;")?;
    writeln!(file)?;

    // CS state enumeration
    writeln!(file, "// CS state enumeration")?;
    writeln!(file, "typedef enum {{")?;
    writeln!(file, "    CS_ACTIVE_LOW,")?;
    writeln!(file, "    CS_ACTIVE_HIGH,")?;
    writeln!(file, "    CS_NOT_USED")?;
    writeln!(file, "}} sdrr_cs_state_t;")?;
    writeln!(file)?;

    // ROM information structure
    writeln!(file, "// ROM information structure")?;
    writeln!(file, "typedef struct {{")?;
    writeln!(
        file,
        "    const uint8_t* data;           // Pointer to ROM data"
    )?;
    writeln!(
        file,
        "    uint16_t size;                 // Actual ROM size (varies by type on F1, always 16384 on F4)"
    )?;
    writeln!(file, "    sdrr_rom_type_t rom_type;      // ROM type")?;
    writeln!(file, "    sdrr_cs_state_t cs1_state;     // CS1 state")?;
    writeln!(file, "    sdrr_cs_state_t cs2_state;     // CS2 state")?;
    writeln!(file, "    sdrr_cs_state_t cs3_state;     // CS3 state")?;
    writeln!(file, "#if defined(BOOT_LOGGING)")?;
    writeln!(
        file,
        "    const char* filename;          // Source filename (BOOT_LOGGING only)"
    )?;
    writeln!(file, "#endif // BOOT_LOGGING")?;
    writeln!(file, "}} sdrr_rom_info_t;")?;
    writeln!(file)?;

    // ROM information array
    writeln!(file, "// ROM information array")?;
    writeln!(
        file,
        "extern const sdrr_rom_info_t sdrr_rom_info[SDRR_NUM_IMAGES];"
    )?;
    writeln!(file)?;

    // Individual ROM data arrays
    writeln!(file, "// Individual ROM data arrays")?;
    for i in 0..config.roms.len() {
        writeln!(
            file,
            "extern const uint8_t sdrr_rom_{}_data[ROM_{}_SIZE];",
            i, i
        )?;
    }
    writeln!(file)?;

    writeln!(file, "#endif // SDRR_ROMS_H")?;

    Ok(())
}

// Generate roms.c implementation file
fn generate_roms_implementation_file(config: &Config, rom_images: &[RomImage]) -> Result<()> {
    const FILENAME: &str = "roms.c";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#include \"roms.h\"")?;
    writeln!(file)?;

    let family = config.stm_variant.family();

    // Generate filename strings (debug only)
    writeln!(file, "// ROM filenames (BOOT_LOGGING only)")?;
    writeln!(file, "#if defined(BOOT_LOGGING)")?;
    for (i, rom_config) in config.roms.iter().enumerate() {
        let source = rom_config
            .extract
            .as_ref()
            .unwrap_or(&rom_config.original_source);
        let filename = source
            .split('/')
            .last()
            .unwrap_or_else(|| panic!("Failed to extract valid filename from source: {}", source));
        writeln!(
            file,
            "static const char sdrr_rom_{}_filename[] = \"{}\";",
            i, filename
        )?;
    }
    writeln!(file, "#endif // BOOT_LOGGING")?;
    writeln!(file)?;

    // Generate ROM information array
    writeln!(file, "// ROM information array")?;
    writeln!(
        file,
        "const sdrr_rom_info_t sdrr_rom_info[SDRR_NUM_IMAGES] = {{"
    )?;

    // Helper function to convert CsLogic to enum string
    let cs_logic_to_enum = |cs_logic: CsLogic| -> &'static str {
        match cs_logic {
            CsLogic::ActiveLow => "CS_ACTIVE_LOW",
            CsLogic::ActiveHigh => "CS_ACTIVE_HIGH",
        }
    };

    for (i, rom_config) in config.roms.iter().enumerate() {
        let rom_type_enum = match rom_config.rom_type {
            crate::rom_types::RomType::Rom2316 => "ROM_TYPE_2316",
            crate::rom_types::RomType::Rom2332 => "ROM_TYPE_2332",
            crate::rom_types::RomType::Rom2364 => "ROM_TYPE_2364",
        };

        let cs1_state = cs_logic_to_enum(rom_config.cs_config.cs1);
        let cs2_state = rom_config
            .cs_config
            .cs2
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");
        let cs3_state = rom_config
            .cs_config
            .cs3
            .map(cs_logic_to_enum)
            .unwrap_or("CS_NOT_USED");

        writeln!(file, "    {{")?;
        writeln!(file, "        .data = sdrr_rom_{}_data,", i)?;
        writeln!(file, "        .size = ROM_{}_SIZE,", i)?;
        writeln!(file, "        .rom_type = {},", rom_type_enum)?;
        writeln!(file, "        .cs1_state = {},", cs1_state)?;
        writeln!(file, "        .cs2_state = {},", cs2_state)?;
        writeln!(file, "        .cs3_state = {},", cs3_state)?;
        writeln!(file, "#if defined(BOOT_LOGGING)")?;
        writeln!(file, "        .filename = sdrr_rom_{}_filename", i)?;
        writeln!(file, "#endif // BOOT_LOGGING")?;
        if i == config.roms.len() - 1 {
            writeln!(file, "    }}")?;
        } else {
            writeln!(file, "    }},")?;
        }
    }

    writeln!(file, "}};")?;
    writeln!(file)?;

    // Generate individual ROM data arrays
    for (i, (rom_config, rom)) in config.roms.iter().zip(rom_images.iter()).enumerate() {
        writeln!(file, "// ROM image {} ({})", i, rom_config.rom_type.name())?;
        writeln!(
            file,
            "const uint8_t sdrr_rom_{}_data[ROM_{}_SIZE] = {{",
            i, i
        )?;

        let rom_len = match family {
            StmFamily::F1 => rom_config.rom_type.size_bytes(),
            StmFamily::F4 => 16384,
        };

        for j in 0..rom_len {
            // 16 bytes per line
            if j % 16 == 0 {
                if j > 0 {
                    writeln!(file)?;
                }
                write!(file, "    ")?;
            }

            let byte = rom.get_byte(j, &family, &rom_config.rom_type);
            write!(file, "0x{:02x}, ", byte)?;
        }

        writeln!(file)?;
        writeln!(file, "}};")?;
        writeln!(file)?;
    }

    Ok(())
}

// Generate sdrr_config.h header file
fn generate_sdrr_config_header(config: &Config) -> Result<()> {
    const FILENAME: &str = "sdrr_config.h";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::C)?;

    writeln!(file, "#ifndef SDRR_CONFIG_H")?;
    writeln!(file, "#define SDRR_CONFIG_H")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Hardware configuration")?;
    writeln!(file, "//")?;

    // STM32 variant
    writeln!(file)?;
    writeln!(file, "// STM32 variant")?;
    writeln!(file, "{}", config.stm_variant.define_var_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_sub_fam())?;
    writeln!(file, "{}", config.stm_variant.define_var_str())?;
    writeln!(file, "{}", config.stm_variant.define_flash_size())?;
    writeln!(file)?;
    writeln!(file, "// SDRR hardware variant")?;
    writeln!(file, "{}", config.hw_rev.unwrap().define())?;
    writeln!(file)?;
    if !config.bootloader {
        writeln!(
            file,
            "#define NO_BOOTLOADER 1  // Jumper based bootloader disabled"
        )?;
    } else {
        writeln!(
            file,
            "// #define NO_BOOTLOADER 0  // Jumper based bootloader enabled"
        )?;
    }
    writeln!(file, "// SDRR hardware revision")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Clocking configuration")?;
    writeln!(file, "//")?;

    // Target frequency
    writeln!(file)?;
    writeln!(file, "// Target frequency")?;
    writeln!(file, "#define TARGET_FREQ_MHZ    {}", config.freq)?;

    // Oscillator config
    writeln!(file)?;
    writeln!(file, "// Oscillator configuration")?;
    if config.hse {
        writeln!(file, "// #define HSI 0")?;
        writeln!(file, "#define HSE 1     // External oscillator selected")?;
    } else {
        writeln!(file, "#define HSI 1     // Internal oscillator selected")?;
        writeln!(file, "// #define HSE 0")?;
    }

    // PLL configuration (F4 family only)
    writeln!(file)?;
    writeln!(file, "// PLL configuration")?;
    if let Some(pll_defines) = config
        .stm_variant
        .generate_pll_defines(config.freq, config.overclock)
    {
        writeln!(file, "{}", pll_defines)?;
        if config.overclock {
            writeln!(file, "#define OVERCLOCK 1  // Overclocking enabled")?;
        } else {
            writeln!(file, "//#define OVERCLOCK 0  // Overclocking disabled")?;
        }
    } else {
        writeln!(file, "// PLL configuration not applicable for this variant")?;
    }

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// ROM configuration")?;
    writeln!(file, "//")?;

    // ROM image sizes by type
    writeln!(file)?;
    writeln!(file, "// ROM image sizes by type (F1 family)")?;
    writeln!(file, "#define ROM_IMAGE_SIZE_2316 2048")?;
    writeln!(file, "#define ROM_IMAGE_SIZE_2332 4096")?;
    writeln!(file, "#define ROM_IMAGE_SIZE_2364 8192")?;
    writeln!(file)?;
    writeln!(
        file,
        "// Maximum ROM image size (F4 family uses a single size for all ROM types)"
    )?;
    writeln!(file, "#define MAX_ROM_IMAGE_SIZE 16384")?;

    writeln!(file)?;
    writeln!(file, "//")?;
    writeln!(file, "// Debug and development configuration")?;
    writeln!(file, "//")?;

    // Preload ROM image to RAM
    writeln!(file)?;
    writeln!(file, "// Preload ROM image to RAM")?;
    if config.preload_to_ram {
        writeln!(file, "#define PRELOAD_TO_RAM 1")?;
    } else {
        writeln!(
            file,
            "// #define PRELOAD_TO_RAM 0  // Preloading to RAM disabled"
        )?;
    }

    // SWD
    writeln!(file)?;
    writeln!(file, "// SWD mode")?;
    if config.swd {
        writeln!(file, "#define SWD 1")?;
    } else {
        writeln!(file, "// #define SWD 0  // SWD mode disabled")?;
    }

    // MCO configuration
    writeln!(file)?;
    writeln!(file, "// MCO configuration")?;
    if config.mco {
        writeln!(file, "#define MCO  1")?;
        if config.mco2 {
            writeln!(file, "#define MCO2 1")?;
        } else {
            writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
        }
    } else {
        writeln!(file, "// #define MCO  0  // MCO not used")?;
        writeln!(file, "// #define MCO2 0  // MCO2 not used")?;
    }

    // Boot logging
    writeln!(file)?;
    writeln!(file, "// Boot logging")?;
    if config.boot_logging {
        writeln!(file, "#define BOOT_LOGGING 1")?;
    } else {
        writeln!(file, "// #define BOOT_LOGGING 0  // Boot logging disabled")?;
    }

    // Main loop logging
    writeln!(file)?;
    writeln!(file, "// Main loop logging")?;
    if config.main_loop_logging {
        writeln!(file, "#define MAIN_LOOP_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define MAIN_LOOP_LOGGING 0  // Main loop logging disabled"
        )?;
    }

    // Debug logging
    writeln!(file)?;
    writeln!(file, "// Debug logging")?;
    if config.debug_logging {
        writeln!(file, "#define DEBUG_LOGGING 1")?;
    } else {
        writeln!(
            file,
            "// #define DEBUG_LOGGING 0  // Debug logging disabled"
        )?;
    }

    // Status LED
    writeln!(file)?;
    writeln!(file, "// Status LED")?;
    if config.status_led {
        writeln!(file, "#define STATUS_LED 1")?;
    } else {
        writeln!(file, "// #define STATUS_LED 0  // Status LED not used")?;
    }

    writeln!(file)?;
    writeln!(file, "#endif // SDRR_CONFIG_H")?;

    Ok(())
}

fn generate_makefile_fragment(config: &Config) -> Result<()> {
    const FILENAME: &str = "generated.mk";
    let mut file = create_file(&config.output_dir, FILENAME, FileType::Makefile)?;

    // STM32 variant
    writeln!(file, "# STM32 variant")?;
    writeln!(file, "VARIANT={}", config.stm_variant.makefile_var())?;

    // probe-rs chip-id
    writeln!(file)?;
    writeln!(file, "# probe-rs Chip ID")?;
    writeln!(file, "PROBE_RS_CHIP_ID={}", config.stm_variant.chip_id())?;

    writeln!(file)?;

    Ok(())
}
